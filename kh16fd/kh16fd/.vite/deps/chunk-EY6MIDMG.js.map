{
  "version": 3,
  "sources": ["../../node_modules/jotai/esm/vanilla/internals.mjs", "../../node_modules/jotai/esm/vanilla.mjs", "../../node_modules/jotai/esm/react.mjs"],
  "sourcesContent": ["function hasInitialValue(atom) {\n  return \"init\" in atom;\n}\nfunction isActuallyWritableAtom(atom) {\n  return !!atom.write;\n}\nfunction isAtomStateInitialized(atomState) {\n  return \"v\" in atomState || \"e\" in atomState;\n}\nfunction returnAtomValue(atomState) {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n}\nconst promiseStateMap = /* @__PURE__ */ new WeakMap();\nfunction isPendingPromise(value) {\n  var _a;\n  return isPromiseLike(value) && !!((_a = promiseStateMap.get(value)) == null ? void 0 : _a[0]);\n}\nfunction abortPromise(promise) {\n  const promiseState = promiseStateMap.get(promise);\n  if (promiseState == null ? void 0 : promiseState[0]) {\n    promiseState[0] = false;\n    promiseState[1].forEach((fn) => fn());\n  }\n}\nfunction registerAbortHandler(promise, abortHandler) {\n  let promiseState = promiseStateMap.get(promise);\n  if (!promiseState) {\n    promiseState = [true, /* @__PURE__ */ new Set()];\n    promiseStateMap.set(promise, promiseState);\n    const settle = () => {\n      promiseState[0] = false;\n    };\n    promise.then(settle, settle);\n  }\n  promiseState[1].add(abortHandler);\n}\nfunction isPromiseLike(p) {\n  return typeof (p == null ? void 0 : p.then) === \"function\";\n}\nfunction addPendingPromiseToDependency(atom, promise, dependencyAtomState) {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    const cleanup = () => dependencyAtomState.p.delete(atom);\n    promise.then(cleanup, cleanup);\n  }\n}\nfunction getMountedOrPendingDependents(atom, atomState, mountedMap) {\n  var _a;\n  const dependents = /* @__PURE__ */ new Set();\n  for (const a of ((_a = mountedMap.get(atom)) == null ? void 0 : _a.t) || []) {\n    if (mountedMap.has(a)) {\n      dependents.add(a);\n    }\n  }\n  for (const atomWithPendingPromise of atomState.p) {\n    dependents.add(atomWithPendingPromise);\n  }\n  return dependents;\n}\nconst createStoreHook = () => {\n  const callbacks = /* @__PURE__ */ new Set();\n  const notify = () => callbacks.forEach((fn) => fn());\n  notify.add = (fn) => {\n    callbacks.add(fn);\n    return () => callbacks.delete(fn);\n  };\n  return notify;\n};\nconst createStoreHookForAtoms = () => {\n  const all = {};\n  const callbacks = /* @__PURE__ */ new WeakMap();\n  const notify = (atom) => {\n    var _a, _b;\n    (_a = callbacks.get(all)) == null ? void 0 : _a.forEach((fn) => fn(atom));\n    (_b = callbacks.get(atom)) == null ? void 0 : _b.forEach((fn) => fn());\n  };\n  notify.add = (atom, fn) => {\n    const key = atom || all;\n    const fns = (callbacks.has(key) ? callbacks : callbacks.set(key, /* @__PURE__ */ new Set())).get(key);\n    fns.add(fn);\n    return () => {\n      fns == null ? void 0 : fns.delete(fn);\n      if (!fns.size) {\n        callbacks.delete(key);\n      }\n    };\n  };\n  return notify;\n};\nfunction initializeStoreHooks(storeHooks) {\n  storeHooks.i || (storeHooks.i = createStoreHookForAtoms());\n  storeHooks.r || (storeHooks.r = createStoreHookForAtoms());\n  storeHooks.c || (storeHooks.c = createStoreHookForAtoms());\n  storeHooks.m || (storeHooks.m = createStoreHookForAtoms());\n  storeHooks.u || (storeHooks.u = createStoreHookForAtoms());\n  storeHooks.f || (storeHooks.f = createStoreHook());\n  return storeHooks;\n}\nconst atomRead = (_store, atom, ...params) => atom.read(...params);\nconst atomWrite = (_store, atom, ...params) => atom.write(...params);\nconst atomOnInit = (store, atom) => {\n  var _a;\n  return (_a = atom.unstable_onInit) == null ? void 0 : _a.call(atom, store);\n};\nconst atomOnMount = (_store, atom, setAtom) => {\n  var _a;\n  return (_a = atom.onMount) == null ? void 0 : _a.call(atom, setAtom);\n};\nconst ensureAtomState = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const atomStateMap = buildingBlocks[0];\n  const storeHooks = buildingBlocks[6];\n  const atomOnInit2 = buildingBlocks[9];\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !atom) {\n    throw new Error(\"Atom is undefined or null\");\n  }\n  let atomState = atomStateMap.get(atom);\n  if (!atomState) {\n    atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n    atomStateMap.set(atom, atomState);\n    (_a = storeHooks.i) == null ? void 0 : _a.call(storeHooks, atom);\n    atomOnInit2 == null ? void 0 : atomOnInit2(store, atom);\n  }\n  return atomState;\n};\nconst flushCallbacks = (store) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const changedAtoms = buildingBlocks[3];\n  const mountCallbacks = buildingBlocks[4];\n  const unmountCallbacks = buildingBlocks[5];\n  const storeHooks = buildingBlocks[6];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const errors = [];\n  const call = (fn) => {\n    try {\n      fn();\n    } catch (e) {\n      errors.push(e);\n    }\n  };\n  do {\n    if (storeHooks.f) {\n      call(storeHooks.f);\n    }\n    const callbacks = /* @__PURE__ */ new Set();\n    const add = callbacks.add.bind(callbacks);\n    changedAtoms.forEach((atom) => {\n      var _a;\n      return (_a = mountedMap.get(atom)) == null ? void 0 : _a.l.forEach(add);\n    });\n    changedAtoms.clear();\n    unmountCallbacks.forEach(add);\n    unmountCallbacks.clear();\n    mountCallbacks.forEach(add);\n    mountCallbacks.clear();\n    callbacks.forEach(call);\n    if (changedAtoms.size) {\n      recomputeInvalidatedAtoms2(store);\n    }\n  } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);\n  if (errors.length) {\n    throw new AggregateError(errors);\n  }\n};\nconst recomputeInvalidatedAtoms = (store) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const changedAtoms = buildingBlocks[3];\n  const ensureAtomState2 = buildingBlocks[11];\n  const readAtomState2 = buildingBlocks[14];\n  const mountDependencies2 = buildingBlocks[17];\n  const topSortedReversed = [];\n  const visiting = /* @__PURE__ */ new WeakSet();\n  const visited = /* @__PURE__ */ new WeakSet();\n  const stack = Array.from(changedAtoms);\n  while (stack.length) {\n    const a = stack[stack.length - 1];\n    const aState = ensureAtomState2(store, a);\n    if (visited.has(a)) {\n      stack.pop();\n      continue;\n    }\n    if (visiting.has(a)) {\n      if (invalidatedAtoms.get(a) === aState.n) {\n        topSortedReversed.push([a, aState]);\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && invalidatedAtoms.has(a)) {\n        throw new Error(\"[Bug] invalidated atom exists\");\n      }\n      visited.add(a);\n      stack.pop();\n      continue;\n    }\n    visiting.add(a);\n    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n      if (!visiting.has(d)) {\n        stack.push(d);\n      }\n    }\n  }\n  for (let i = topSortedReversed.length - 1; i >= 0; --i) {\n    const [a, aState] = topSortedReversed[i];\n    let hasChangedDeps = false;\n    for (const dep of aState.d.keys()) {\n      if (dep !== a && changedAtoms.has(dep)) {\n        hasChangedDeps = true;\n        break;\n      }\n    }\n    if (hasChangedDeps) {\n      readAtomState2(store, a);\n      mountDependencies2(store, a);\n    }\n    invalidatedAtoms.delete(a);\n  }\n};\nconst storeMutationSet = /* @__PURE__ */ new WeakSet();\nconst readAtomState = (store, atom) => {\n  var _a, _b;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const atomRead2 = buildingBlocks[7];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const writeAtomState2 = buildingBlocks[16];\n  const mountDependencies2 = buildingBlocks[17];\n  const atomState = ensureAtomState2(store, atom);\n  if (isAtomStateInitialized(atomState)) {\n    if (mountedMap.has(atom) && invalidatedAtoms.get(atom) !== atomState.n) {\n      return atomState;\n    }\n    if (Array.from(atomState.d).every(\n      ([a, n]) => (\n        // Recursively, read the atom state of the dependency, and\n        // check if the atom epoch number is unchanged\n        readAtomState2(store, a).n === n\n      )\n    )) {\n      return atomState;\n    }\n  }\n  atomState.d.clear();\n  let isSync = true;\n  function mountDependenciesIfAsync() {\n    if (mountedMap.has(atom)) {\n      mountDependencies2(store, atom);\n      recomputeInvalidatedAtoms2(store);\n      flushCallbacks2(store);\n    }\n  }\n  function getter(a) {\n    var _a2;\n    if (a === atom) {\n      const aState2 = ensureAtomState2(store, a);\n      if (!isAtomStateInitialized(aState2)) {\n        if (hasInitialValue(a)) {\n          setAtomStateValueOrPromise(store, a, a.init);\n        } else {\n          throw new Error(\"no atom init\");\n        }\n      }\n      return returnAtomValue(aState2);\n    }\n    const aState = readAtomState2(store, a);\n    try {\n      return returnAtomValue(aState);\n    } finally {\n      atomState.d.set(a, aState.n);\n      if (isPendingPromise(atomState.v)) {\n        addPendingPromiseToDependency(atom, atomState.v, aState);\n      }\n      (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom);\n      if (!isSync) {\n        mountDependenciesIfAsync();\n      }\n    }\n  }\n  let controller;\n  let setSelf;\n  const options = {\n    get signal() {\n      if (!controller) {\n        controller = new AbortController();\n      }\n      return controller.signal;\n    },\n    get setSelf() {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n        console.warn(\"setSelf function cannot be used with read-only atom\");\n      }\n      if (!setSelf && isActuallyWritableAtom(atom)) {\n        setSelf = (...args) => {\n          if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n            console.warn(\"setSelf function cannot be called in sync\");\n          }\n          if (!isSync) {\n            try {\n              return writeAtomState2(store, atom, ...args);\n            } finally {\n              recomputeInvalidatedAtoms2(store);\n              flushCallbacks2(store);\n            }\n          }\n        };\n      }\n      return setSelf;\n    }\n  };\n  const prevEpochNumber = atomState.n;\n  try {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeMutationSet.delete(store);\n    }\n    const valueOrPromise = atomRead2(store, atom, getter, options);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && storeMutationSet.has(store)) {\n      console.warn(\n        \"Detected store mutation during atom read. This is not supported.\"\n      );\n    }\n    setAtomStateValueOrPromise(store, atom, valueOrPromise);\n    if (isPromiseLike(valueOrPromise)) {\n      registerAbortHandler(valueOrPromise, () => controller == null ? void 0 : controller.abort());\n      valueOrPromise.then(mountDependenciesIfAsync, mountDependenciesIfAsync);\n    }\n    (_a = storeHooks.r) == null ? void 0 : _a.call(storeHooks, atom);\n    return atomState;\n  } catch (error) {\n    delete atomState.v;\n    atomState.e = error;\n    ++atomState.n;\n    return atomState;\n  } finally {\n    isSync = false;\n    if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom) === prevEpochNumber) {\n      invalidatedAtoms.set(atom, atomState.n);\n      changedAtoms.add(atom);\n      (_b = storeHooks.c) == null ? void 0 : _b.call(storeHooks, atom);\n    }\n  }\n};\nconst invalidateDependents = (store, atom) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const ensureAtomState2 = buildingBlocks[11];\n  const stack = [atom];\n  while (stack.length) {\n    const a = stack.pop();\n    const aState = ensureAtomState2(store, a);\n    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n      const dState = ensureAtomState2(store, d);\n      invalidatedAtoms.set(d, dState.n);\n      stack.push(d);\n    }\n  }\n};\nconst writeAtomState = (store, atom, ...args) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const atomWrite2 = buildingBlocks[8];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const invalidateDependents2 = buildingBlocks[15];\n  const mountDependencies2 = buildingBlocks[17];\n  let isSync = true;\n  const getter = (a) => returnAtomValue(readAtomState2(store, a));\n  const setter = (a, ...args2) => {\n    var _a;\n    const aState = ensureAtomState2(store, a);\n    try {\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeMutationSet.add(store);\n        }\n        const prevEpochNumber = aState.n;\n        const v = args2[0];\n        setAtomStateValueOrPromise(store, a, v);\n        mountDependencies2(store, a);\n        if (prevEpochNumber !== aState.n) {\n          changedAtoms.add(a);\n          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n          invalidateDependents2(store, a);\n        }\n        return void 0;\n      } else {\n        return writeAtomState(store, a, ...args2);\n      }\n    } finally {\n      if (!isSync) {\n        recomputeInvalidatedAtoms2(store);\n        flushCallbacks2(store);\n      }\n    }\n  };\n  try {\n    return atomWrite2(store, atom, getter, setter, ...args);\n  } finally {\n    isSync = false;\n  }\n};\nconst mountDependencies = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const ensureAtomState2 = buildingBlocks[11];\n  const invalidateDependents2 = buildingBlocks[15];\n  const mountAtom2 = buildingBlocks[18];\n  const unmountAtom2 = buildingBlocks[19];\n  const atomState = ensureAtomState2(store, atom);\n  const mounted = mountedMap.get(atom);\n  if (mounted && !isPendingPromise(atomState.v)) {\n    for (const [a, n] of atomState.d) {\n      if (!mounted.d.has(a)) {\n        const aState = ensureAtomState2(store, a);\n        const aMounted = mountAtom2(store, a);\n        aMounted.t.add(atom);\n        mounted.d.add(a);\n        if (n !== aState.n) {\n          changedAtoms.add(a);\n          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n          invalidateDependents2(store, a);\n        }\n      }\n    }\n    for (const a of mounted.d || []) {\n      if (!atomState.d.has(a)) {\n        mounted.d.delete(a);\n        const aMounted = unmountAtom2(store, a);\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n    }\n  }\n};\nconst mountAtom = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const mountCallbacks = buildingBlocks[4];\n  const storeHooks = buildingBlocks[6];\n  const atomOnMount2 = buildingBlocks[10];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const writeAtomState2 = buildingBlocks[16];\n  const atomState = ensureAtomState2(store, atom);\n  let mounted = mountedMap.get(atom);\n  if (!mounted) {\n    readAtomState2(store, atom);\n    for (const a of atomState.d.keys()) {\n      const aMounted = mountAtom(store, a);\n      aMounted.t.add(atom);\n    }\n    mounted = {\n      l: /* @__PURE__ */ new Set(),\n      d: new Set(atomState.d.keys()),\n      t: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom);\n    if (isActuallyWritableAtom(atom)) {\n      const processOnMount = () => {\n        let isSync = true;\n        const setAtom = (...args) => {\n          try {\n            return writeAtomState2(store, atom, ...args);\n          } finally {\n            if (!isSync) {\n              recomputeInvalidatedAtoms2(store);\n              flushCallbacks2(store);\n            }\n          }\n        };\n        try {\n          const onUnmount = atomOnMount2(store, atom, setAtom);\n          if (onUnmount) {\n            mounted.u = () => {\n              isSync = true;\n              try {\n                onUnmount();\n              } finally {\n                isSync = false;\n              }\n            };\n          }\n        } finally {\n          isSync = false;\n        }\n      };\n      mountCallbacks.add(processOnMount);\n    }\n  }\n  return mounted;\n};\nconst unmountAtom = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const unmountCallbacks = buildingBlocks[5];\n  const storeHooks = buildingBlocks[6];\n  const ensureAtomState2 = buildingBlocks[11];\n  const unmountAtom2 = buildingBlocks[19];\n  const atomState = ensureAtomState2(store, atom);\n  let mounted = mountedMap.get(atom);\n  if (mounted && !mounted.l.size && !Array.from(mounted.t).some((a) => {\n    var _a2;\n    return (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.d.has(atom);\n  })) {\n    if (mounted.u) {\n      unmountCallbacks.add(mounted.u);\n    }\n    mounted = void 0;\n    mountedMap.delete(atom);\n    (_a = storeHooks.u) == null ? void 0 : _a.call(storeHooks, atom);\n    for (const a of atomState.d.keys()) {\n      const aMounted = unmountAtom2(store, a);\n      aMounted == null ? void 0 : aMounted.t.delete(atom);\n    }\n    return void 0;\n  }\n  return mounted;\n};\nconst setAtomStateValueOrPromise = (store, atom, valueOrPromise) => {\n  const ensureAtomState2 = getInternalBuildingBlocks(store)[11];\n  const atomState = ensureAtomState2(store, atom);\n  const hasPrevValue = \"v\" in atomState;\n  const prevValue = atomState.v;\n  if (isPromiseLike(valueOrPromise)) {\n    for (const a of atomState.d.keys()) {\n      addPendingPromiseToDependency(\n        atom,\n        valueOrPromise,\n        ensureAtomState2(store, a)\n      );\n    }\n  }\n  atomState.v = valueOrPromise;\n  delete atomState.e;\n  if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n    ++atomState.n;\n    if (isPromiseLike(prevValue)) {\n      abortPromise(prevValue);\n    }\n  }\n};\nconst storeGet = (store, atom) => {\n  const readAtomState2 = getInternalBuildingBlocks(store)[14];\n  return returnAtomValue(readAtomState2(store, atom));\n};\nconst storeSet = (store, atom, ...args) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const writeAtomState2 = buildingBlocks[16];\n  try {\n    return writeAtomState2(store, atom, ...args);\n  } finally {\n    recomputeInvalidatedAtoms2(store);\n    flushCallbacks2(store);\n  }\n};\nconst storeSub = (store, atom, listener) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const flushCallbacks2 = buildingBlocks[12];\n  const mountAtom2 = buildingBlocks[18];\n  const unmountAtom2 = buildingBlocks[19];\n  const mounted = mountAtom2(store, atom);\n  const listeners = mounted.l;\n  listeners.add(listener);\n  flushCallbacks2(store);\n  return () => {\n    listeners.delete(listener);\n    unmountAtom2(store, atom);\n    flushCallbacks2(store);\n  };\n};\nconst buildingBlockMap = /* @__PURE__ */ new WeakMap();\nconst getInternalBuildingBlocks = (store) => {\n  const buildingBlocks = buildingBlockMap.get(store);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !buildingBlocks) {\n    throw new Error(\n      \"Store must be created by buildStore to read its building blocks\"\n    );\n  }\n  return buildingBlocks;\n};\nfunction getBuildingBlocks(store) {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const enhanceBuildingBlocks = buildingBlocks[24];\n  if (enhanceBuildingBlocks) {\n    return enhanceBuildingBlocks(buildingBlocks);\n  }\n  return buildingBlocks;\n}\nfunction buildStore(...buildArgs) {\n  const store = {\n    get(atom) {\n      const storeGet2 = getInternalBuildingBlocks(store)[21];\n      return storeGet2(store, atom);\n    },\n    set(atom, ...args) {\n      const storeSet2 = getInternalBuildingBlocks(store)[22];\n      return storeSet2(store, atom, ...args);\n    },\n    sub(atom, listener) {\n      const storeSub2 = getInternalBuildingBlocks(store)[23];\n      return storeSub2(store, atom, listener);\n    }\n  };\n  const buildingBlocks = [\n    // store state\n    /* @__PURE__ */ new WeakMap(),\n    // atomStateMap\n    /* @__PURE__ */ new WeakMap(),\n    // mountedMap\n    /* @__PURE__ */ new WeakMap(),\n    // invalidatedAtoms\n    /* @__PURE__ */ new Set(),\n    // changedAtoms\n    /* @__PURE__ */ new Set(),\n    // mountCallbacks\n    /* @__PURE__ */ new Set(),\n    // unmountCallbacks\n    {},\n    // storeHooks\n    // atom interceptors\n    atomRead,\n    atomWrite,\n    atomOnInit,\n    atomOnMount,\n    // building-block functions\n    ensureAtomState,\n    flushCallbacks,\n    recomputeInvalidatedAtoms,\n    readAtomState,\n    invalidateDependents,\n    writeAtomState,\n    mountDependencies,\n    mountAtom,\n    unmountAtom,\n    setAtomStateValueOrPromise,\n    storeGet,\n    storeSet,\n    storeSub,\n    void 0\n  ].map((fn, i) => buildArgs[i] || fn);\n  buildingBlockMap.set(store, Object.freeze(buildingBlocks));\n  return store;\n}\n\nexport { abortPromise as INTERNAL_abortPromise, addPendingPromiseToDependency as INTERNAL_addPendingPromiseToDependency, buildStore as INTERNAL_buildStoreRev2, getBuildingBlocks as INTERNAL_getBuildingBlocksRev2, getMountedOrPendingDependents as INTERNAL_getMountedOrPendingDependents, hasInitialValue as INTERNAL_hasInitialValue, initializeStoreHooks as INTERNAL_initializeStoreHooksRev2, isActuallyWritableAtom as INTERNAL_isActuallyWritableAtom, isAtomStateInitialized as INTERNAL_isAtomStateInitialized, isPendingPromise as INTERNAL_isPendingPromise, isPromiseLike as INTERNAL_isPromiseLike, promiseStateMap as INTERNAL_promiseStateMap, registerAbortHandler as INTERNAL_registerAbortHandler, returnAtomValue as INTERNAL_returnAtomValue };\n", "import { INTERNAL_buildStoreRev2 } from 'jotai/vanilla/internals';\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nlet overiddenCreateStore;\nfunction INTERNAL_overrideCreateStore(fn) {\n  overiddenCreateStore = fn(overiddenCreateStore);\n}\nfunction createStore() {\n  if (overiddenCreateStore) {\n    return overiddenCreateStore();\n  }\n  return INTERNAL_buildStoreRev2();\n}\nlet defaultStore;\nfunction getDefaultStore() {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n}\n\nexport { INTERNAL_overrideCreateStore, atom, createStore, getDefaultStore };\n", "'use client';\nimport React, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\nimport { INTERNAL_registerAbortHandler } from 'jotai/vanilla/internals';\n\nconst StoreContext = createContext(\n  void 0\n);\nfunction useStore(options) {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n}\nfunction Provider({\n  children,\n  store\n}) {\n  const storeRef = useRef(null);\n  if (store) {\n    return createElement(StoreContext.Provider, { value: store }, children);\n  }\n  if (storeRef.current === null) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      // TODO should we use useState instead?\n      // eslint-disable-next-line react-hooks/refs\n      value: storeRef.current\n    },\n    children\n  );\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst attachPromiseStatus = (promise) => {\n  if (!promise.status) {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n  }\n};\nconst use = React.use || // A shim for older React versions\n((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    attachPromiseStatus(promise);\n    throw promise;\n  }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise, getValue) => {\n  let continuablePromise = continuablePromiseMap.get(promise);\n  if (!continuablePromise) {\n    continuablePromise = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          resolve(v);\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          reject(e);\n        }\n      };\n      const onAbort = () => {\n        try {\n          const nextValue = getValue();\n          if (isPromiseLike(nextValue)) {\n            continuablePromiseMap.set(nextValue, continuablePromise);\n            curr = nextValue;\n            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n            INTERNAL_registerAbortHandler(nextValue, onAbort);\n          } else {\n            resolve(nextValue);\n          }\n        } catch (e) {\n          reject(e);\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      INTERNAL_registerAbortHandler(promise, onAbort);\n    });\n    continuablePromiseMap.set(promise, continuablePromise);\n  }\n  return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n  const { delay, unstable_promiseStatus: promiseStatus = !React.use } = options || {};\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (promiseStatus) {\n        try {\n          const value2 = store.get(atom);\n          if (isPromiseLike(value2)) {\n            attachPromiseStatus(\n              createContinuablePromise(value2, () => store.get(atom))\n            );\n          }\n        } catch (e) {\n        }\n      }\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay, promiseStatus]);\n  useDebugValue(value);\n  if (isPromiseLike(value)) {\n    const promise = createContinuablePromise(value, () => store.get(atom));\n    if (promiseStatus) {\n      attachPromiseStatus(promise);\n    }\n    return use(promise);\n  }\n  return value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],
  "mappings": ";;;;;;;;AAAA,SAAS,gBAAgBA,OAAM;AAC7B,SAAO,UAAUA;AACnB;AACA,SAAS,uBAAuBA,OAAM;AACpC,SAAO,CAAC,CAACA,MAAK;AAChB;AACA,SAAS,uBAAuB,WAAW;AACzC,SAAO,OAAO,aAAa,OAAO;AACpC;AACA,SAAS,gBAAgB,WAAW;AAClC,MAAI,OAAO,WAAW;AACpB,UAAM,UAAU;AAAA,EAClB;AACA,OAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,EAAE,OAAO,YAAY;AAC7F,UAAM,IAAI,MAAM,qCAAqC;AAAA,EACvD;AACA,SAAO,UAAU;AACnB;AACA,IAAM,kBAAkC,oBAAI,QAAQ;AACpD,SAAS,iBAAiB,OAAO;AAC/B,MAAI;AACJ,SAAO,cAAc,KAAK,KAAK,CAAC,GAAG,KAAK,gBAAgB,IAAI,KAAK,MAAM,OAAO,SAAS,GAAG,CAAC;AAC7F;AACA,SAAS,aAAa,SAAS;AAC7B,QAAM,eAAe,gBAAgB,IAAI,OAAO;AAChD,MAAI,gBAAgB,OAAO,SAAS,aAAa,CAAC,GAAG;AACnD,iBAAa,CAAC,IAAI;AAClB,iBAAa,CAAC,EAAE,QAAQ,CAAC,OAAO,GAAG,CAAC;AAAA,EACtC;AACF;AACA,SAAS,qBAAqB,SAAS,cAAc;AACnD,MAAI,eAAe,gBAAgB,IAAI,OAAO;AAC9C,MAAI,CAAC,cAAc;AACjB,mBAAe,CAAC,MAAsB,oBAAI,IAAI,CAAC;AAC/C,oBAAgB,IAAI,SAAS,YAAY;AACzC,UAAM,SAAS,MAAM;AACnB,mBAAa,CAAC,IAAI;AAAA,IACpB;AACA,YAAQ,KAAK,QAAQ,MAAM;AAAA,EAC7B;AACA,eAAa,CAAC,EAAE,IAAI,YAAY;AAClC;AACA,SAAS,cAAc,GAAG;AACxB,SAAO,QAAQ,KAAK,OAAO,SAAS,EAAE,UAAU;AAClD;AACA,SAAS,8BAA8BA,OAAM,SAAS,qBAAqB;AACzE,MAAI,CAAC,oBAAoB,EAAE,IAAIA,KAAI,GAAG;AACpC,wBAAoB,EAAE,IAAIA,KAAI;AAC9B,UAAM,UAAU,MAAM,oBAAoB,EAAE,OAAOA,KAAI;AACvD,YAAQ,KAAK,SAAS,OAAO;AAAA,EAC/B;AACF;AACA,SAAS,8BAA8BA,OAAM,WAAW,YAAY;AAClE,MAAI;AACJ,QAAM,aAA6B,oBAAI,IAAI;AAC3C,aAAW,OAAO,KAAK,WAAW,IAAIA,KAAI,MAAM,OAAO,SAAS,GAAG,MAAM,CAAC,GAAG;AAC3E,QAAI,WAAW,IAAI,CAAC,GAAG;AACrB,iBAAW,IAAI,CAAC;AAAA,IAClB;AAAA,EACF;AACA,aAAW,0BAA0B,UAAU,GAAG;AAChD,eAAW,IAAI,sBAAsB;AAAA,EACvC;AACA,SAAO;AACT;AACA,IAAM,kBAAkB,MAAM;AAC5B,QAAM,YAA4B,oBAAI,IAAI;AAC1C,QAAM,SAAS,MAAM,UAAU,QAAQ,CAAC,OAAO,GAAG,CAAC;AACnD,SAAO,MAAM,CAAC,OAAO;AACnB,cAAU,IAAI,EAAE;AAChB,WAAO,MAAM,UAAU,OAAO,EAAE;AAAA,EAClC;AACA,SAAO;AACT;AACA,IAAM,0BAA0B,MAAM;AACpC,QAAM,MAAM,CAAC;AACb,QAAM,YAA4B,oBAAI,QAAQ;AAC9C,QAAM,SAAS,CAACA,UAAS;AACvB,QAAI,IAAI;AACR,KAAC,KAAK,UAAU,IAAI,GAAG,MAAM,OAAO,SAAS,GAAG,QAAQ,CAAC,OAAO,GAAGA,KAAI,CAAC;AACxE,KAAC,KAAK,UAAU,IAAIA,KAAI,MAAM,OAAO,SAAS,GAAG,QAAQ,CAAC,OAAO,GAAG,CAAC;AAAA,EACvE;AACA,SAAO,MAAM,CAACA,OAAM,OAAO;AACzB,UAAM,MAAMA,SAAQ;AACpB,UAAM,OAAO,UAAU,IAAI,GAAG,IAAI,YAAY,UAAU,IAAI,KAAqB,oBAAI,IAAI,CAAC,GAAG,IAAI,GAAG;AACpG,QAAI,IAAI,EAAE;AACV,WAAO,MAAM;AACX,aAAO,OAAO,SAAS,IAAI,OAAO,EAAE;AACpC,UAAI,CAAC,IAAI,MAAM;AACb,kBAAU,OAAO,GAAG;AAAA,MACtB;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,qBAAqB,YAAY;AACxC,aAAW,MAAM,WAAW,IAAI,wBAAwB;AACxD,aAAW,MAAM,WAAW,IAAI,wBAAwB;AACxD,aAAW,MAAM,WAAW,IAAI,wBAAwB;AACxD,aAAW,MAAM,WAAW,IAAI,wBAAwB;AACxD,aAAW,MAAM,WAAW,IAAI,wBAAwB;AACxD,aAAW,MAAM,WAAW,IAAI,gBAAgB;AAChD,SAAO;AACT;AACA,IAAM,WAAW,CAAC,QAAQA,UAAS,WAAWA,MAAK,KAAK,GAAG,MAAM;AACjE,IAAM,YAAY,CAAC,QAAQA,UAAS,WAAWA,MAAK,MAAM,GAAG,MAAM;AACnE,IAAM,aAAa,CAAC,OAAOA,UAAS;AAClC,MAAI;AACJ,UAAQ,KAAKA,MAAK,oBAAoB,OAAO,SAAS,GAAG,KAAKA,OAAM,KAAK;AAC3E;AACA,IAAM,cAAc,CAAC,QAAQA,OAAM,YAAY;AAC7C,MAAI;AACJ,UAAQ,KAAKA,MAAK,YAAY,OAAO,SAAS,GAAG,KAAKA,OAAM,OAAO;AACrE;AACA,IAAM,kBAAkB,CAAC,OAAOA,UAAS;AACvC,MAAI;AACJ,QAAM,iBAAiB,0BAA0B,KAAK;AACtD,QAAM,eAAe,eAAe,CAAC;AACrC,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,cAAc,eAAe,CAAC;AACpC,OAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,CAACA,OAAM;AAC/E,UAAM,IAAI,MAAM,2BAA2B;AAAA,EAC7C;AACA,MAAI,YAAY,aAAa,IAAIA,KAAI;AACrC,MAAI,CAAC,WAAW;AACd,gBAAY,EAAE,GAAmB,oBAAI,IAAI,GAAG,GAAmB,oBAAI,IAAI,GAAG,GAAG,EAAE;AAC/E,iBAAa,IAAIA,OAAM,SAAS;AAChC,KAAC,KAAK,WAAW,MAAM,OAAO,SAAS,GAAG,KAAK,YAAYA,KAAI;AAC/D,mBAAe,OAAO,SAAS,YAAY,OAAOA,KAAI;AAAA,EACxD;AACA,SAAO;AACT;AACA,IAAM,iBAAiB,CAAC,UAAU;AAChC,QAAM,iBAAiB,0BAA0B,KAAK;AACtD,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,eAAe,eAAe,CAAC;AACrC,QAAM,iBAAiB,eAAe,CAAC;AACvC,QAAM,mBAAmB,eAAe,CAAC;AACzC,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,6BAA6B,eAAe,EAAE;AACpD,QAAM,SAAS,CAAC;AAChB,QAAM,OAAO,CAAC,OAAO;AACnB,QAAI;AACF,SAAG;AAAA,IACL,SAAS,GAAG;AACV,aAAO,KAAK,CAAC;AAAA,IACf;AAAA,EACF;AACA,KAAG;AACD,QAAI,WAAW,GAAG;AAChB,WAAK,WAAW,CAAC;AAAA,IACnB;AACA,UAAM,YAA4B,oBAAI,IAAI;AAC1C,UAAM,MAAM,UAAU,IAAI,KAAK,SAAS;AACxC,iBAAa,QAAQ,CAACA,UAAS;AAC7B,UAAI;AACJ,cAAQ,KAAK,WAAW,IAAIA,KAAI,MAAM,OAAO,SAAS,GAAG,EAAE,QAAQ,GAAG;AAAA,IACxE,CAAC;AACD,iBAAa,MAAM;AACnB,qBAAiB,QAAQ,GAAG;AAC5B,qBAAiB,MAAM;AACvB,mBAAe,QAAQ,GAAG;AAC1B,mBAAe,MAAM;AACrB,cAAU,QAAQ,IAAI;AACtB,QAAI,aAAa,MAAM;AACrB,iCAA2B,KAAK;AAAA,IAClC;AAAA,EACF,SAAS,aAAa,QAAQ,iBAAiB,QAAQ,eAAe;AACtE,MAAI,OAAO,QAAQ;AACjB,UAAM,IAAI,eAAe,MAAM;AAAA,EACjC;AACF;AACA,IAAM,4BAA4B,CAAC,UAAU;AAC3C,QAAM,iBAAiB,0BAA0B,KAAK;AACtD,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,mBAAmB,eAAe,CAAC;AACzC,QAAM,eAAe,eAAe,CAAC;AACrC,QAAM,mBAAmB,eAAe,EAAE;AAC1C,QAAM,iBAAiB,eAAe,EAAE;AACxC,QAAM,qBAAqB,eAAe,EAAE;AAC5C,QAAM,oBAAoB,CAAC;AAC3B,QAAM,WAA2B,oBAAI,QAAQ;AAC7C,QAAM,UAA0B,oBAAI,QAAQ;AAC5C,QAAM,QAAQ,MAAM,KAAK,YAAY;AACrC,SAAO,MAAM,QAAQ;AACnB,UAAM,IAAI,MAAM,MAAM,SAAS,CAAC;AAChC,UAAM,SAAS,iBAAiB,OAAO,CAAC;AACxC,QAAI,QAAQ,IAAI,CAAC,GAAG;AAClB,YAAM,IAAI;AACV;AAAA,IACF;AACA,QAAI,SAAS,IAAI,CAAC,GAAG;AACnB,UAAI,iBAAiB,IAAI,CAAC,MAAM,OAAO,GAAG;AACxC,0BAAkB,KAAK,CAAC,GAAG,MAAM,CAAC;AAAA,MACpC,YAAY,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,iBAAiB,IAAI,CAAC,GAAG;AACxG,cAAM,IAAI,MAAM,+BAA+B;AAAA,MACjD;AACA,cAAQ,IAAI,CAAC;AACb,YAAM,IAAI;AACV;AAAA,IACF;AACA,aAAS,IAAI,CAAC;AACd,eAAW,KAAK,8BAA8B,GAAG,QAAQ,UAAU,GAAG;AACpE,UAAI,CAAC,SAAS,IAAI,CAAC,GAAG;AACpB,cAAM,KAAK,CAAC;AAAA,MACd;AAAA,IACF;AAAA,EACF;AACA,WAAS,IAAI,kBAAkB,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACtD,UAAM,CAAC,GAAG,MAAM,IAAI,kBAAkB,CAAC;AACvC,QAAI,iBAAiB;AACrB,eAAW,OAAO,OAAO,EAAE,KAAK,GAAG;AACjC,UAAI,QAAQ,KAAK,aAAa,IAAI,GAAG,GAAG;AACtC,yBAAiB;AACjB;AAAA,MACF;AAAA,IACF;AACA,QAAI,gBAAgB;AAClB,qBAAe,OAAO,CAAC;AACvB,yBAAmB,OAAO,CAAC;AAAA,IAC7B;AACA,qBAAiB,OAAO,CAAC;AAAA,EAC3B;AACF;AACA,IAAM,mBAAmC,oBAAI,QAAQ;AACrD,IAAM,gBAAgB,CAAC,OAAOA,UAAS;AACrC,MAAI,IAAI;AACR,QAAM,iBAAiB,0BAA0B,KAAK;AACtD,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,mBAAmB,eAAe,CAAC;AACzC,QAAM,eAAe,eAAe,CAAC;AACrC,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,YAAY,eAAe,CAAC;AAClC,QAAM,mBAAmB,eAAe,EAAE;AAC1C,QAAM,kBAAkB,eAAe,EAAE;AACzC,QAAM,6BAA6B,eAAe,EAAE;AACpD,QAAM,iBAAiB,eAAe,EAAE;AACxC,QAAM,kBAAkB,eAAe,EAAE;AACzC,QAAM,qBAAqB,eAAe,EAAE;AAC5C,QAAM,YAAY,iBAAiB,OAAOA,KAAI;AAC9C,MAAI,uBAAuB,SAAS,GAAG;AACrC,QAAI,WAAW,IAAIA,KAAI,KAAK,iBAAiB,IAAIA,KAAI,MAAM,UAAU,GAAG;AACtE,aAAO;AAAA,IACT;AACA,QAAI,MAAM,KAAK,UAAU,CAAC,EAAE;AAAA,MAC1B,CAAC,CAAC,GAAG,CAAC;AAAA;AAAA;AAAA,QAGJ,eAAe,OAAO,CAAC,EAAE,MAAM;AAAA;AAAA,IAEnC,GAAG;AACD,aAAO;AAAA,IACT;AAAA,EACF;AACA,YAAU,EAAE,MAAM;AAClB,MAAI,SAAS;AACb,WAAS,2BAA2B;AAClC,QAAI,WAAW,IAAIA,KAAI,GAAG;AACxB,yBAAmB,OAAOA,KAAI;AAC9B,iCAA2B,KAAK;AAChC,sBAAgB,KAAK;AAAA,IACvB;AAAA,EACF;AACA,WAAS,OAAO,GAAG;AACjB,QAAI;AACJ,QAAI,MAAMA,OAAM;AACd,YAAM,UAAU,iBAAiB,OAAO,CAAC;AACzC,UAAI,CAAC,uBAAuB,OAAO,GAAG;AACpC,YAAI,gBAAgB,CAAC,GAAG;AACtB,qCAA2B,OAAO,GAAG,EAAE,IAAI;AAAA,QAC7C,OAAO;AACL,gBAAM,IAAI,MAAM,cAAc;AAAA,QAChC;AAAA,MACF;AACA,aAAO,gBAAgB,OAAO;AAAA,IAChC;AACA,UAAM,SAAS,eAAe,OAAO,CAAC;AACtC,QAAI;AACF,aAAO,gBAAgB,MAAM;AAAA,IAC/B,UAAE;AACA,gBAAU,EAAE,IAAI,GAAG,OAAO,CAAC;AAC3B,UAAI,iBAAiB,UAAU,CAAC,GAAG;AACjC,sCAA8BA,OAAM,UAAU,GAAG,MAAM;AAAA,MACzD;AACA,OAAC,MAAM,WAAW,IAAI,CAAC,MAAM,OAAO,SAAS,IAAI,EAAE,IAAIA,KAAI;AAC3D,UAAI,CAAC,QAAQ;AACX,iCAAyB;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;AACA,MAAI;AACJ,MAAI;AACJ,QAAM,UAAU;AAAA,IACd,IAAI,SAAS;AACX,UAAI,CAAC,YAAY;AACf,qBAAa,IAAI,gBAAgB;AAAA,MACnC;AACA,aAAO,WAAW;AAAA,IACpB;AAAA,IACA,IAAI,UAAU;AACZ,WAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,CAAC,uBAAuBA,KAAI,GAAG;AACvG,gBAAQ,KAAK,qDAAqD;AAAA,MACpE;AACA,UAAI,CAAC,WAAW,uBAAuBA,KAAI,GAAG;AAC5C,kBAAU,IAAI,SAAS;AACrB,eAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,QAAQ;AAChF,oBAAQ,KAAK,2CAA2C;AAAA,UAC1D;AACA,cAAI,CAAC,QAAQ;AACX,gBAAI;AACF,qBAAO,gBAAgB,OAAOA,OAAM,GAAG,IAAI;AAAA,YAC7C,UAAE;AACA,yCAA2B,KAAK;AAChC,8BAAgB,KAAK;AAAA,YACvB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACA,QAAM,kBAAkB,UAAU;AAClC,MAAI;AACF,SAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,uBAAiB,OAAO,KAAK;AAAA,IAC/B;AACA,UAAM,iBAAiB,UAAU,OAAOA,OAAM,QAAQ,OAAO;AAC7D,SAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,iBAAiB,IAAI,KAAK,GAAG;AACrG,cAAQ;AAAA,QACN;AAAA,MACF;AAAA,IACF;AACA,+BAA2B,OAAOA,OAAM,cAAc;AACtD,QAAI,cAAc,cAAc,GAAG;AACjC,2BAAqB,gBAAgB,MAAM,cAAc,OAAO,SAAS,WAAW,MAAM,CAAC;AAC3F,qBAAe,KAAK,0BAA0B,wBAAwB;AAAA,IACxE;AACA,KAAC,KAAK,WAAW,MAAM,OAAO,SAAS,GAAG,KAAK,YAAYA,KAAI;AAC/D,WAAO;AAAA,EACT,SAAS,OAAO;AACd,WAAO,UAAU;AACjB,cAAU,IAAI;AACd,MAAE,UAAU;AACZ,WAAO;AAAA,EACT,UAAE;AACA,aAAS;AACT,QAAI,oBAAoB,UAAU,KAAK,iBAAiB,IAAIA,KAAI,MAAM,iBAAiB;AACrF,uBAAiB,IAAIA,OAAM,UAAU,CAAC;AACtC,mBAAa,IAAIA,KAAI;AACrB,OAAC,KAAK,WAAW,MAAM,OAAO,SAAS,GAAG,KAAK,YAAYA,KAAI;AAAA,IACjE;AAAA,EACF;AACF;AACA,IAAM,uBAAuB,CAAC,OAAOA,UAAS;AAC5C,QAAM,iBAAiB,0BAA0B,KAAK;AACtD,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,mBAAmB,eAAe,CAAC;AACzC,QAAM,mBAAmB,eAAe,EAAE;AAC1C,QAAM,QAAQ,CAACA,KAAI;AACnB,SAAO,MAAM,QAAQ;AACnB,UAAM,IAAI,MAAM,IAAI;AACpB,UAAM,SAAS,iBAAiB,OAAO,CAAC;AACxC,eAAW,KAAK,8BAA8B,GAAG,QAAQ,UAAU,GAAG;AACpE,YAAM,SAAS,iBAAiB,OAAO,CAAC;AACxC,uBAAiB,IAAI,GAAG,OAAO,CAAC;AAChC,YAAM,KAAK,CAAC;AAAA,IACd;AAAA,EACF;AACF;AACA,IAAM,iBAAiB,CAAC,OAAOA,UAAS,SAAS;AAC/C,QAAM,iBAAiB,0BAA0B,KAAK;AACtD,QAAM,eAAe,eAAe,CAAC;AACrC,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,mBAAmB,eAAe,EAAE;AAC1C,QAAM,kBAAkB,eAAe,EAAE;AACzC,QAAM,6BAA6B,eAAe,EAAE;AACpD,QAAM,iBAAiB,eAAe,EAAE;AACxC,QAAM,wBAAwB,eAAe,EAAE;AAC/C,QAAM,qBAAqB,eAAe,EAAE;AAC5C,MAAI,SAAS;AACb,QAAM,SAAS,CAAC,MAAM,gBAAgB,eAAe,OAAO,CAAC,CAAC;AAC9D,QAAM,SAAS,CAAC,MAAM,UAAU;AAC9B,QAAI;AACJ,UAAM,SAAS,iBAAiB,OAAO,CAAC;AACxC,QAAI;AACF,UAAI,MAAMA,OAAM;AACd,YAAI,CAAC,gBAAgB,CAAC,GAAG;AACvB,gBAAM,IAAI,MAAM,mBAAmB;AAAA,QACrC;AACA,aAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,2BAAiB,IAAI,KAAK;AAAA,QAC5B;AACA,cAAM,kBAAkB,OAAO;AAC/B,cAAM,IAAI,MAAM,CAAC;AACjB,mCAA2B,OAAO,GAAG,CAAC;AACtC,2BAAmB,OAAO,CAAC;AAC3B,YAAI,oBAAoB,OAAO,GAAG;AAChC,uBAAa,IAAI,CAAC;AAClB,WAAC,KAAK,WAAW,MAAM,OAAO,SAAS,GAAG,KAAK,YAAY,CAAC;AAC5D,gCAAsB,OAAO,CAAC;AAAA,QAChC;AACA,eAAO;AAAA,MACT,OAAO;AACL,eAAO,eAAe,OAAO,GAAG,GAAG,KAAK;AAAA,MAC1C;AAAA,IACF,UAAE;AACA,UAAI,CAAC,QAAQ;AACX,mCAA2B,KAAK;AAChC,wBAAgB,KAAK;AAAA,MACvB;AAAA,IACF;AAAA,EACF;AACA,MAAI;AACF,WAAO,WAAW,OAAOA,OAAM,QAAQ,QAAQ,GAAG,IAAI;AAAA,EACxD,UAAE;AACA,aAAS;AAAA,EACX;AACF;AACA,IAAM,oBAAoB,CAAC,OAAOA,UAAS;AACzC,MAAI;AACJ,QAAM,iBAAiB,0BAA0B,KAAK;AACtD,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,eAAe,eAAe,CAAC;AACrC,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,mBAAmB,eAAe,EAAE;AAC1C,QAAM,wBAAwB,eAAe,EAAE;AAC/C,QAAM,aAAa,eAAe,EAAE;AACpC,QAAM,eAAe,eAAe,EAAE;AACtC,QAAM,YAAY,iBAAiB,OAAOA,KAAI;AAC9C,QAAM,UAAU,WAAW,IAAIA,KAAI;AACnC,MAAI,WAAW,CAAC,iBAAiB,UAAU,CAAC,GAAG;AAC7C,eAAW,CAAC,GAAG,CAAC,KAAK,UAAU,GAAG;AAChC,UAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,GAAG;AACrB,cAAM,SAAS,iBAAiB,OAAO,CAAC;AACxC,cAAM,WAAW,WAAW,OAAO,CAAC;AACpC,iBAAS,EAAE,IAAIA,KAAI;AACnB,gBAAQ,EAAE,IAAI,CAAC;AACf,YAAI,MAAM,OAAO,GAAG;AAClB,uBAAa,IAAI,CAAC;AAClB,WAAC,KAAK,WAAW,MAAM,OAAO,SAAS,GAAG,KAAK,YAAY,CAAC;AAC5D,gCAAsB,OAAO,CAAC;AAAA,QAChC;AAAA,MACF;AAAA,IACF;AACA,eAAW,KAAK,QAAQ,KAAK,CAAC,GAAG;AAC/B,UAAI,CAAC,UAAU,EAAE,IAAI,CAAC,GAAG;AACvB,gBAAQ,EAAE,OAAO,CAAC;AAClB,cAAM,WAAW,aAAa,OAAO,CAAC;AACtC,oBAAY,OAAO,SAAS,SAAS,EAAE,OAAOA,KAAI;AAAA,MACpD;AAAA,IACF;AAAA,EACF;AACF;AACA,IAAM,YAAY,CAAC,OAAOA,UAAS;AACjC,MAAI;AACJ,QAAM,iBAAiB,0BAA0B,KAAK;AACtD,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,iBAAiB,eAAe,CAAC;AACvC,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,eAAe,eAAe,EAAE;AACtC,QAAM,mBAAmB,eAAe,EAAE;AAC1C,QAAM,kBAAkB,eAAe,EAAE;AACzC,QAAM,6BAA6B,eAAe,EAAE;AACpD,QAAM,iBAAiB,eAAe,EAAE;AACxC,QAAM,kBAAkB,eAAe,EAAE;AACzC,QAAM,YAAY,iBAAiB,OAAOA,KAAI;AAC9C,MAAI,UAAU,WAAW,IAAIA,KAAI;AACjC,MAAI,CAAC,SAAS;AACZ,mBAAe,OAAOA,KAAI;AAC1B,eAAW,KAAK,UAAU,EAAE,KAAK,GAAG;AAClC,YAAM,WAAW,UAAU,OAAO,CAAC;AACnC,eAAS,EAAE,IAAIA,KAAI;AAAA,IACrB;AACA,cAAU;AAAA,MACR,GAAmB,oBAAI,IAAI;AAAA,MAC3B,GAAG,IAAI,IAAI,UAAU,EAAE,KAAK,CAAC;AAAA,MAC7B,GAAmB,oBAAI,IAAI;AAAA,IAC7B;AACA,eAAW,IAAIA,OAAM,OAAO;AAC5B,KAAC,KAAK,WAAW,MAAM,OAAO,SAAS,GAAG,KAAK,YAAYA,KAAI;AAC/D,QAAI,uBAAuBA,KAAI,GAAG;AAChC,YAAM,iBAAiB,MAAM;AAC3B,YAAI,SAAS;AACb,cAAM,UAAU,IAAI,SAAS;AAC3B,cAAI;AACF,mBAAO,gBAAgB,OAAOA,OAAM,GAAG,IAAI;AAAA,UAC7C,UAAE;AACA,gBAAI,CAAC,QAAQ;AACX,yCAA2B,KAAK;AAChC,8BAAgB,KAAK;AAAA,YACvB;AAAA,UACF;AAAA,QACF;AACA,YAAI;AACF,gBAAM,YAAY,aAAa,OAAOA,OAAM,OAAO;AACnD,cAAI,WAAW;AACb,oBAAQ,IAAI,MAAM;AAChB,uBAAS;AACT,kBAAI;AACF,0BAAU;AAAA,cACZ,UAAE;AACA,yBAAS;AAAA,cACX;AAAA,YACF;AAAA,UACF;AAAA,QACF,UAAE;AACA,mBAAS;AAAA,QACX;AAAA,MACF;AACA,qBAAe,IAAI,cAAc;AAAA,IACnC;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAM,cAAc,CAAC,OAAOA,UAAS;AACnC,MAAI;AACJ,QAAM,iBAAiB,0BAA0B,KAAK;AACtD,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,mBAAmB,eAAe,CAAC;AACzC,QAAM,aAAa,eAAe,CAAC;AACnC,QAAM,mBAAmB,eAAe,EAAE;AAC1C,QAAM,eAAe,eAAe,EAAE;AACtC,QAAM,YAAY,iBAAiB,OAAOA,KAAI;AAC9C,MAAI,UAAU,WAAW,IAAIA,KAAI;AACjC,MAAI,WAAW,CAAC,QAAQ,EAAE,QAAQ,CAAC,MAAM,KAAK,QAAQ,CAAC,EAAE,KAAK,CAAC,MAAM;AACnE,QAAI;AACJ,YAAQ,MAAM,WAAW,IAAI,CAAC,MAAM,OAAO,SAAS,IAAI,EAAE,IAAIA,KAAI;AAAA,EACpE,CAAC,GAAG;AACF,QAAI,QAAQ,GAAG;AACb,uBAAiB,IAAI,QAAQ,CAAC;AAAA,IAChC;AACA,cAAU;AACV,eAAW,OAAOA,KAAI;AACtB,KAAC,KAAK,WAAW,MAAM,OAAO,SAAS,GAAG,KAAK,YAAYA,KAAI;AAC/D,eAAW,KAAK,UAAU,EAAE,KAAK,GAAG;AAClC,YAAM,WAAW,aAAa,OAAO,CAAC;AACtC,kBAAY,OAAO,SAAS,SAAS,EAAE,OAAOA,KAAI;AAAA,IACpD;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AACA,IAAM,6BAA6B,CAAC,OAAOA,OAAM,mBAAmB;AAClE,QAAM,mBAAmB,0BAA0B,KAAK,EAAE,EAAE;AAC5D,QAAM,YAAY,iBAAiB,OAAOA,KAAI;AAC9C,QAAM,eAAe,OAAO;AAC5B,QAAM,YAAY,UAAU;AAC5B,MAAI,cAAc,cAAc,GAAG;AACjC,eAAW,KAAK,UAAU,EAAE,KAAK,GAAG;AAClC;AAAA,QACEA;AAAA,QACA;AAAA,QACA,iBAAiB,OAAO,CAAC;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;AACA,YAAU,IAAI;AACd,SAAO,UAAU;AACjB,MAAI,CAAC,gBAAgB,CAAC,OAAO,GAAG,WAAW,UAAU,CAAC,GAAG;AACvD,MAAE,UAAU;AACZ,QAAI,cAAc,SAAS,GAAG;AAC5B,mBAAa,SAAS;AAAA,IACxB;AAAA,EACF;AACF;AACA,IAAM,WAAW,CAAC,OAAOA,UAAS;AAChC,QAAM,iBAAiB,0BAA0B,KAAK,EAAE,EAAE;AAC1D,SAAO,gBAAgB,eAAe,OAAOA,KAAI,CAAC;AACpD;AACA,IAAM,WAAW,CAAC,OAAOA,UAAS,SAAS;AACzC,QAAM,iBAAiB,0BAA0B,KAAK;AACtD,QAAM,kBAAkB,eAAe,EAAE;AACzC,QAAM,6BAA6B,eAAe,EAAE;AACpD,QAAM,kBAAkB,eAAe,EAAE;AACzC,MAAI;AACF,WAAO,gBAAgB,OAAOA,OAAM,GAAG,IAAI;AAAA,EAC7C,UAAE;AACA,+BAA2B,KAAK;AAChC,oBAAgB,KAAK;AAAA,EACvB;AACF;AACA,IAAM,WAAW,CAAC,OAAOA,OAAM,aAAa;AAC1C,QAAM,iBAAiB,0BAA0B,KAAK;AACtD,QAAM,kBAAkB,eAAe,EAAE;AACzC,QAAM,aAAa,eAAe,EAAE;AACpC,QAAM,eAAe,eAAe,EAAE;AACtC,QAAM,UAAU,WAAW,OAAOA,KAAI;AACtC,QAAM,YAAY,QAAQ;AAC1B,YAAU,IAAI,QAAQ;AACtB,kBAAgB,KAAK;AACrB,SAAO,MAAM;AACX,cAAU,OAAO,QAAQ;AACzB,iBAAa,OAAOA,KAAI;AACxB,oBAAgB,KAAK;AAAA,EACvB;AACF;AACA,IAAM,mBAAmC,oBAAI,QAAQ;AACrD,IAAM,4BAA4B,CAAC,UAAU;AAC3C,QAAM,iBAAiB,iBAAiB,IAAI,KAAK;AACjD,OAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,CAAC,gBAAgB;AACzF,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AASA,SAAS,cAAc,WAAW;AAChC,QAAM,QAAQ;AAAA,IACZ,IAAIC,OAAM;AACR,YAAM,YAAY,0BAA0B,KAAK,EAAE,EAAE;AACrD,aAAO,UAAU,OAAOA,KAAI;AAAA,IAC9B;AAAA,IACA,IAAIA,UAAS,MAAM;AACjB,YAAM,YAAY,0BAA0B,KAAK,EAAE,EAAE;AACrD,aAAO,UAAU,OAAOA,OAAM,GAAG,IAAI;AAAA,IACvC;AAAA,IACA,IAAIA,OAAM,UAAU;AAClB,YAAM,YAAY,0BAA0B,KAAK,EAAE,EAAE;AACrD,aAAO,UAAU,OAAOA,OAAM,QAAQ;AAAA,IACxC;AAAA,EACF;AACA,QAAM,iBAAiB;AAAA;AAAA,IAEL,oBAAI,QAAQ;AAAA;AAAA,IAEZ,oBAAI,QAAQ;AAAA;AAAA,IAEZ,oBAAI,QAAQ;AAAA;AAAA,IAEZ,oBAAI,IAAI;AAAA;AAAA,IAER,oBAAI,IAAI;AAAA;AAAA,IAER,oBAAI,IAAI;AAAA;AAAA,IAExB,CAAC;AAAA;AAAA;AAAA,IAGD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,EAAE,IAAI,CAAC,IAAI,MAAM,UAAU,CAAC,KAAK,EAAE;AACnC,mBAAiB,IAAI,OAAO,OAAO,OAAO,cAAc,CAAC;AACzD,SAAO;AACT;;;AC3pBA,IAAI,WAAW;AACf,SAAS,KAAK,MAAM,OAAO;AACzB,QAAM,MAAM,OAAO,EAAE,QAAQ;AAC7B,QAAM,SAAS;AAAA,IACb,WAAW;AACT,cAAQ,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,KAAK,aAAa,MAAM,MAAM,KAAK,aAAa;AAAA,IAC/H;AAAA,EACF;AACA,MAAI,OAAO,SAAS,YAAY;AAC9B,WAAO,OAAO;AAAA,EAChB,OAAO;AACL,WAAO,OAAO;AACd,WAAO,OAAO;AACd,WAAO,QAAQ;AAAA,EACjB;AACA,MAAI,OAAO;AACT,WAAO,QAAQ;AAAA,EACjB;AACA,SAAO;AACT;AACA,SAAS,YAAY,KAAK;AACxB,SAAO,IAAI,IAAI;AACjB;AACA,SAAS,aAAa,KAAK,KAAK,KAAK;AACnC,SAAO;AAAA,IACL;AAAA,IACA,OAAO,QAAQ,aAAa,IAAI,IAAI,IAAI,CAAC,IAAI;AAAA,EAC/C;AACF;AAEA,IAAI;AACJ,SAAS,6BAA6B,IAAI;AACxC,yBAAuB,GAAG,oBAAoB;AAChD;AACA,SAAS,cAAc;AACrB,MAAI,sBAAsB;AACxB,WAAO,qBAAqB;AAAA,EAC9B;AACA,SAAO,WAAwB;AACjC;AACA,IAAI;AACJ,SAAS,kBAAkB;AACzB,MAAI,CAAC,cAAc;AACjB,mBAAe,YAAY;AAC3B,SAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,iBAAW,4BAA4B,WAAW,0BAA0B;AAC5E,UAAI,WAAW,4BAA4B,cAAc;AACvD,gBAAQ;AAAA,UACN;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;;;ACvDA,mBAA2H;AAI3H,IAAM,mBAAe;AAAA,EACnB;AACF;AACA,SAAS,SAAS,SAAS;AACzB,QAAM,YAAQ,yBAAW,YAAY;AACrC,UAAQ,WAAW,OAAO,SAAS,QAAQ,UAAU,SAAS,gBAAgB;AAChF;AACA,SAAS,SAAS;AAAA,EAChB;AAAA,EACA;AACF,GAAG;AACD,QAAM,eAAW,qBAAO,IAAI;AAC5B,MAAI,OAAO;AACT,eAAO,4BAAc,aAAa,UAAU,EAAE,OAAO,MAAM,GAAG,QAAQ;AAAA,EACxE;AACA,MAAI,SAAS,YAAY,MAAM;AAC7B,aAAS,UAAU,YAAY;AAAA,EACjC;AACA,aAAO;AAAA,IACL,aAAa;AAAA,IACb;AAAA;AAAA;AAAA,MAGE,OAAO,SAAS;AAAA,IAClB;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAMC,iBAAgB,CAAC,MAAM,QAAQ,KAAK,OAAO,SAAS,EAAE,UAAU;AACtE,IAAM,sBAAsB,CAAC,YAAY;AACvC,MAAI,CAAC,QAAQ,QAAQ;AACnB,YAAQ,SAAS;AACjB,YAAQ;AAAA,MACN,CAAC,MAAM;AACL,gBAAQ,SAAS;AACjB,gBAAQ,QAAQ;AAAA,MAClB;AAAA,MACA,CAAC,MAAM;AACL,gBAAQ,SAAS;AACjB,gBAAQ,SAAS;AAAA,MACnB;AAAA,IACF;AAAA,EACF;AACF;AACA,IAAM,MAAM,aAAAC,QAAM;AAAA,CACjB,CAAC,YAAY;AACZ,MAAI,QAAQ,WAAW,WAAW;AAChC,UAAM;AAAA,EACR,WAAW,QAAQ,WAAW,aAAa;AACzC,WAAO,QAAQ;AAAA,EACjB,WAAW,QAAQ,WAAW,YAAY;AACxC,UAAM,QAAQ;AAAA,EAChB,OAAO;AACL,wBAAoB,OAAO;AAC3B,UAAM;AAAA,EACR;AACF;AACA,IAAM,wBAAwC,oBAAI,QAAQ;AAC1D,IAAM,2BAA2B,CAAC,SAAS,aAAa;AACtD,MAAI,qBAAqB,sBAAsB,IAAI,OAAO;AAC1D,MAAI,CAAC,oBAAoB;AACvB,yBAAqB,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpD,UAAI,OAAO;AACX,YAAM,cAAc,CAAC,OAAO,CAAC,MAAM;AACjC,YAAI,SAAS,IAAI;AACf,kBAAQ,CAAC;AAAA,QACX;AAAA,MACF;AACA,YAAM,aAAa,CAAC,OAAO,CAAC,MAAM;AAChC,YAAI,SAAS,IAAI;AACf,iBAAO,CAAC;AAAA,QACV;AAAA,MACF;AACA,YAAM,UAAU,MAAM;AACpB,YAAI;AACF,gBAAM,YAAY,SAAS;AAC3B,cAAID,eAAc,SAAS,GAAG;AAC5B,kCAAsB,IAAI,WAAW,kBAAkB;AACvD,mBAAO;AACP,sBAAU,KAAK,YAAY,SAAS,GAAG,WAAW,SAAS,CAAC;AAC5D,iCAA8B,WAAW,OAAO;AAAA,UAClD,OAAO;AACL,oBAAQ,SAAS;AAAA,UACnB;AAAA,QACF,SAAS,GAAG;AACV,iBAAO,CAAC;AAAA,QACV;AAAA,MACF;AACA,cAAQ,KAAK,YAAY,OAAO,GAAG,WAAW,OAAO,CAAC;AACtD,2BAA8B,SAAS,OAAO;AAAA,IAChD,CAAC;AACD,0BAAsB,IAAI,SAAS,kBAAkB;AAAA,EACvD;AACA,SAAO;AACT;AACA,SAAS,aAAaE,OAAM,SAAS;AACnC,QAAM,EAAE,OAAO,wBAAwB,gBAAgB,CAAC,aAAAD,QAAM,IAAI,IAAI,WAAW,CAAC;AAClF,QAAM,QAAQ,SAAS,OAAO;AAC9B,QAAM,CAAC,CAAC,kBAAkB,kBAAkB,eAAe,GAAG,QAAQ,QAAI;AAAA,IACxE,CAAC,SAAS;AACR,YAAM,YAAY,MAAM,IAAIC,KAAI;AAChC,UAAI,OAAO,GAAG,KAAK,CAAC,GAAG,SAAS,KAAK,KAAK,CAAC,MAAM,SAAS,KAAK,CAAC,MAAMA,OAAM;AAC1E,eAAO;AAAA,MACT;AACA,aAAO,CAAC,WAAW,OAAOA,KAAI;AAAA,IAChC;AAAA,IACA;AAAA,IACA,MAAM,CAAC,MAAM,IAAIA,KAAI,GAAG,OAAOA,KAAI;AAAA,EACrC;AACA,MAAI,QAAQ;AACZ,MAAI,qBAAqB,SAAS,oBAAoBA,OAAM;AAC1D,aAAS;AACT,YAAQ,MAAM,IAAIA,KAAI;AAAA,EACxB;AACA,8BAAU,MAAM;AACd,UAAM,QAAQ,MAAM,IAAIA,OAAM,MAAM;AAClC,UAAI,eAAe;AACjB,YAAI;AACF,gBAAM,SAAS,MAAM,IAAIA,KAAI;AAC7B,cAAIF,eAAc,MAAM,GAAG;AACzB;AAAA,cACE,yBAAyB,QAAQ,MAAM,MAAM,IAAIE,KAAI,CAAC;AAAA,YACxD;AAAA,UACF;AAAA,QACF,SAAS,GAAG;AAAA,QACZ;AAAA,MACF;AACA,UAAI,OAAO,UAAU,UAAU;AAC7B,mBAAW,UAAU,KAAK;AAC1B;AAAA,MACF;AACA,eAAS;AAAA,IACX,CAAC;AACD,aAAS;AACT,WAAO;AAAA,EACT,GAAG,CAAC,OAAOA,OAAM,OAAO,aAAa,CAAC;AACtC,kCAAc,KAAK;AACnB,MAAIF,eAAc,KAAK,GAAG;AACxB,UAAM,UAAU,yBAAyB,OAAO,MAAM,MAAM,IAAIE,KAAI,CAAC;AACrE,QAAI,eAAe;AACjB,0BAAoB,OAAO;AAAA,IAC7B;AACA,WAAO,IAAI,OAAO;AAAA,EACpB;AACA,SAAO;AACT;AAEA,SAAS,WAAWA,OAAM,SAAS;AACjC,QAAM,QAAQ,SAAS,OAAO;AAC9B,QAAM,cAAU;AAAA,IACd,IAAI,SAAS;AACX,WAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,EAAE,WAAWA,QAAO;AAC5F,cAAM,IAAI,MAAM,mBAAmB;AAAA,MACrC;AACA,aAAO,MAAM,IAAIA,OAAM,GAAG,IAAI;AAAA,IAChC;AAAA,IACA,CAAC,OAAOA,KAAI;AAAA,EACd;AACA,SAAO;AACT;AAEA,SAAS,QAAQA,OAAM,SAAS;AAC9B,SAAO;AAAA,IACL,aAAaA,OAAM,OAAO;AAAA;AAAA,IAE1B,WAAWA,OAAM,OAAO;AAAA,EAC1B;AACF;",
  "names": ["atom", "atom", "isPromiseLike", "React", "atom"]
}
